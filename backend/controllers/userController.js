import validator from "validator";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import userModel from "../models/userModel.js";
import referralModel from "../models/referralModel.js";
import mongoose from "mongoose";
// T·∫°o token JWT d·ª±a tr√™n ID ng∆∞·ªùi d√πng
const createToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET);
};

// H√†m t·∫°o m√£ gi·ªõi thi·ªáu duy nh·∫•t g·ªìm 6 ch·ªØ s·ªë
const generateUniqueReferralCode = async () => {
  let code;
  let exists;
  do {
    code = `190${Math.floor(100000 + Math.random() * 900000)}`; // T·∫°o m√£ ng·∫´u nhi√™n
    exists = await userModel.findOne({ referralCode: code }); // Ki·ªÉm tra xem m√£ ƒë√£ t·ªìn t·∫°i ch∆∞a
  } while (exists);
  return code;
};

// X·ª≠ l√Ω ƒëƒÉng k√Ω ng∆∞·ªùi d√πng
const registerUser = async (req, res) => {
  try {
    const { name, email, password, referralCode } = req.body;

    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    const exists = await userModel.findOne({ email });
    if (exists) {
      return res.status(400).json({ success: false, message: "Email ƒë√£ t·ªìn t·∫°i." });
    }

    // Ki·ªÉm tra email v√† m·∫≠t kh·∫©u h·ª£p l·ªá
    if (!validator.isEmail(email)) {
      return res.status(400).json({ success: false, message: "Email kh√¥ng h·ª£p l·ªá." });
    }
    if (password.length < 8) {
      return res.status(400).json({ success: false, message: "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 8 k√Ω t·ª±." });
    }

    // M√£ h√≥a m·∫≠t kh·∫©u
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // T·∫°o ng∆∞·ªùi d√πng m·ªõi
    const newUser = new userModel({
      name,
      email,
      password: hashedPassword,
      referralCode: await generateUniqueReferralCode(), // T·∫°o m√£ gi·ªõi thi·ªáu m·ªõi
    });

    // Ki·ªÉm tra m√£ gi·ªõi thi·ªáu
    if (referralCode) {
      const referrer = await userModel.findOne({ referralCode });
      if (referrer && referrer._id.toString() !== newUser._id.toString()) {
        // C·ªông ƒëi·ªÉm th∆∞·ªüng cho ng∆∞·ªùi gi·ªõi thi·ªáu
        await userModel.findByIdAndUpdate(referrer._id, { $inc: { points: 10 } });

        // L∆∞u th√¥ng tin gi·ªõi thi·ªáu v√†o b·∫£ng Referral
        await referralModel.create({
          referrerId: referrer._id,
          referredUserId: newUser._id,
          referralCode,
        });
      }
    }

    // L∆∞u ng∆∞·ªùi d√πng m·ªõi v√†o database
    const user = await newUser.save();

    // T·∫°o token JWT
    const token = createToken(user._id);

    res.status(201).json({
      success: true,
      token,
      userId: user._id,
      referralCode: user.referralCode,
      message: "ƒêƒÉng k√Ω th√†nh c√¥ng!",
    });
  } catch (error) {
    console.error("L·ªói khi ƒëƒÉng k√Ω:", error.message);
    res.status(500).json({ success: false, message: "L·ªói server." });
  }
};

// H√†m x·ª≠ l√Ω nh·∫≠p m√£ gi·ªõi thi·ªáu v√† c·∫•p ƒëi·ªÉm
const redeemReferral = async (req, res) => {
  try {
    const { referralCode } = req.body;
    const { authorization } = req.headers;

    if (!authorization) {
      return res.status(401).json({ success: false, message: "Unauthorized" });
    }

    const token = authorization.split(" ")[1]; 
    const decoded = jwt.verify(token, process.env.JWT_SECRET); 

    const user = await userModel.findById(decoded.id);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }

    // Ki·ªÉm tra n·∫øu ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p m√£ gi·ªõi thi·ªáu tr∆∞·ªõc ƒë√≥
    const existingReferral = await referralModel.findOne({ referredUserId: user._id });
    if (existingReferral) {
      return res.status(400).json({ success: false, message: "B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ gi·ªõi thi·ªáu tr∆∞·ªõc ƒë√≥." });
    }

    // Kh√¥ng cho ph√©p ng∆∞·ªùi d√πng nh·∫≠p m√£ c·ªßa ch√≠nh m√¨nh
    const referrer = await userModel.findOne({ referralCode });
    if (!referrer) {
      return res.status(400).json({ success: false, message: "M√£ gi·ªõi thi·ªáu kh√¥ng h·ª£p l·ªá." });
    }
    if (referrer._id.equals(user._id)) {
      return res.status(400).json({ success: false, message: "Kh√¥ng th·ªÉ s·ª≠ d·ª•ng m√£ gi·ªõi thi·ªáu c·ªßa ch√≠nh b·∫°n." });
    }

    // C·∫≠p nh·∫≠t ƒëi·ªÉm th∆∞·ªüng cho ng∆∞·ªùi gi·ªõi thi·ªáu
    const points = 10; 
    referrer.points = (referrer.points || 0) + points;
    await referrer.save();

    // L∆∞u th√¥ng tin v√†o b·∫£ng Referral
    await referralModel.create({
      referrerId: referrer._id,
      referredUserId: user._id,
      referralCode,
    });

    res.json({ success: true, message: "M√£ gi·ªõi thi·ªáu h·ª£p l·ªá! Ng∆∞·ªùi gi·ªõi thi·ªáu ƒë√£ nh·∫≠n ƒëi·ªÉm th∆∞·ªüng.", points });
  } catch (error) {
    console.error("Error redeeming referral code:", error.message);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
};

// L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
const getUserProfile = async (req, res) => {
  try {
    const { userId } = req.query; // L·∫•y userId t·ª´ query
    if (!userId) {
      return res.status(400).json({ success: false, message: "Thi·∫øu userId." });
    }

    const user = await userModel.findById(userId).select("-password");
    if (!user) {
      return res.status(404).json({ success: false, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng." });
    }

    res.json({ success: true, user });
  } catch (error) {
    console.error("L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng:", error.message);
    res.status(500).json({ success: false, message: "L·ªói server." });
  }
};

// ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng
const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await userModel.findOne({ email });
    if (!user) {
      return res.json({ success: false, message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i." });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (isMatch) {
      const token = createToken(user._id);
      res.json({ success: true, token, userId: user._id });
    } else {
      res.json({ success: false, message: "Sai th√¥ng tin ƒëƒÉng nh·∫≠p." });
    }
  } catch (error) {
    console.error("L·ªói ƒëƒÉng nh·∫≠p:", error.message);
    res.json({ success: false, message: "L·ªói server." });
  }
};

// ƒêƒÉng nh·∫≠p Admin
const adminLogin = async (req, res) => {
  try {
    const { email, password } = req.body;
    if (email === process.env.ADMIN_EMAIL && password === process.env.ADMIN_PASSWORD) {
      const token = jwt.sign({ email }, process.env.JWT_SECRET);
      res.json({ success: true, token });
    } else {
      res.json({ success: false, message: "Sai th√¥ng tin ƒëƒÉng nh·∫≠p." });
    }
  } catch (error) {
    console.error("L·ªói khi ƒëƒÉng nh·∫≠p Admin:", error.message);
    res.status(500).json({ success: false, message: "L·ªói server." });
  }
};


// H√†m c·∫≠p nh·∫≠t avatar c·ªßa ng∆∞·ªùi d√πng
const updateAvatar = async (req, res) => {
  try {
    const { userId } = req.body;
    if (!userId) {
      return res.status(400).json({ success: false, message: "Thi·∫øu userId." });
    }

    if (!req.file) {
      return res.status(400).json({ success: false, message: "Ch∆∞a ch·ªçn ·∫£nh." });
    }

    const avatarPath = `/uploads/${req.file.filename}`;

    // Chuy·ªÉn userId sang ObjectId h·ª£p l·ªá
    const userObjectId = new mongoose.Types.ObjectId(userId);

    // C·∫≠p nh·∫≠t avatar v√†o database
    const user = await userModel.findByIdAndUpdate(
      userId,
      { $set: { avatar: avatarPath } },
      { new: true } // Tr·∫£ v·ªÅ b·∫£n ghi sau khi c·∫≠p nh·∫≠t
    );
    
    if (!user) {
      return res.status(404).json({ success: false, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng." });
    }
    
    console.log("üìå K·∫øt qu·∫£ c·∫≠p nh·∫≠t:", user);
    res.json({ success: true, avatar: user.avatar });
  } catch (error) {
    console.error("L·ªói khi c·∫≠p nh·∫≠t avatar:", error);
    res.status(500).json({ success: false, message: "L·ªói server." });
  }
};



export { loginUser, registerUser, adminLogin, getUserProfile, redeemReferral, updateAvatar };
